[
  {
    "question": "Каково назначение MonoBehaviour в Unity?",
    "answer": "MonoBehaviour — это базовый класс для скриптов, которые привязываются к GameObject и участвуют в жизненном цикле событий Unity.",
    "tags": [
      "MonoBehaviour",
      "Lifecycle",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Чем отличаются Awake и Start?",
    "answer": "Awake вызывается при загрузке объекта, а Start — перед первым Update, когда объект уже включен.",
    "tags": [
      "MonoBehaviour",
      "Lifecycle",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Когда следует использовать FixedUpdate вместо Update?",
    "answer": "FixedUpdate используйте для физики и сил, а Update — для логики по кадрам и обработки ввода.",
    "tags": [
      "MonoBehaviour",
      "Lifecycle",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Что такое LateUpdate и когда он полезен?",
    "answer": "LateUpdate вызывается после всех Update и подходит для зависимой логики, например следования камеры.",
    "tags": [
      "MonoBehaviour",
      "Lifecycle",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Может ли Start быть корутиной?",
    "answer": "Да, Start может возвращать IEnumerator и использовать yield для поэтапной инициализации.",
    "tags": [
      "MonoBehaviour",
      "Lifecycle",
      "C#",
      "Корутины"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Как правильно уничтожать объекты во время выполнения?",
    "answer": "Для удаления в рантайме используйте Destroy(obj), а для временного отключения без удаления — SetActive(false).",
    "tags": [
      "MonoBehaviour",
      "Lifecycle",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Когда вызывается OnCollisionEnter и что нужно для его срабатывания?",
    "answer": "OnCollisionEnter срабатывает при начале контакта коллайдеров, если хотя бы у одного есть некинематический Rigidbody.",
    "tags": [
      "MonoBehaviour",
      "Lifecycle",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Почему не стоит напрямую изменять Transform у Rigidbody?",
    "answer": "Прямое изменение Transform обходит физический движок и может вызвать нестабильные столкновения и движение.",
    "tags": [
      "MonoBehaviour",
      "Lifecycle",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Что такое WaitForSeconds и как на него влияет Time.timeScale?",
    "answer": "WaitForSeconds приостанавливает корутину в масштабируемом времени, поэтому длительность умножается на Time.timeScale.",
    "tags": [
      "MonoBehaviour",
      "Lifecycle",
      "C#",
      "Корутины",
      "Time"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Что такое корутина в Unity и чем она отличается от многопоточности?",
    "answer": "Корутина — это выполнение логики по кадрам на главном потоке; это не настоящая параллельная многопоточность.",
    "tags": [
      "MonoBehaviour",
      "Lifecycle",
      "C#",
      "Корутины",
      "ECS"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что такое GameObject в Unity?",
    "answer": "GameObject — базовый объект сцены, а поведение он получает через прикрепленные компоненты.",
    "tags": [
      "GameObject",
      "Компоненты",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Что такое Component и как компоненты связаны с GameObject?",
    "answer": "Компоненты — это модульные блоки данных и поведения, которые добавляются к GameObject.",
    "tags": [
      "GameObject",
      "Компоненты",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Почему у каждого GameObject есть Transform?",
    "answer": "Transform хранит позицию, вращение и масштаб и обязателен для размещения объекта в сцене.",
    "tags": [
      "GameObject",
      "Компоненты",
      "C#",
      "Transform"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Чем отличаются теги (Tags) и слои (Layers), и для чего они нужны?",
    "answer": "Tags служат для идентификации объектов в коде, а Layers — для фильтрации рендера, света и физики.",
    "tags": [
      "GameObject",
      "Компоненты",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "В чем разница между отключением GameObject и отключением Component?",
    "answer": "SetActive(false) отключает объект и его дочерние элементы, а отключение Component останавливает только этот компонент.",
    "tags": [
      "GameObject",
      "Компоненты",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Как добавить Component к GameObject в скрипте?",
    "answer": "Вызовите gameObject.AddComponent<YourType>(), чтобы создать и добавить компонент во время выполнения.",
    "tags": [
      "GameObject",
      "Компоненты",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Что такое Prefab и почему они полезны?",
    "answer": "Prefab — это переиспользуемый шаблон настроенного GameObject для быстрого создания экземпляров и единых обновлений.",
    "tags": [
      "GameObject",
      "Компоненты",
      "C#",
      "Prefab"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Что такое вложенный Prefab?",
    "answer": "Вложенный Prefab — это Prefab внутри другого Prefab, удобно для сборки сложных объектов из частей.",
    "tags": [
      "GameObject",
      "Компоненты",
      "C#",
      "Prefab"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Как создать экземпляр Prefab во время выполнения?",
    "answer": "Используйте Instantiate(prefab, position, rotation), чтобы создать экземпляр в рантайме.",
    "tags": [
      "GameObject",
      "Компоненты",
      "C#",
      "Prefab"
    ],
    "difficulty": "easy"
  },
  {
    "question": "В чем разница между GameObject и Prefab?",
    "answer": "GameObject — экземпляр в сцене, Prefab — asset-шаблон для создания таких экземпляров.",
    "tags": [
      "GameObject",
      "Компоненты",
      "C#",
      "Prefab"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Как организовать GameObject иерархически?",
    "answer": "Используйте связи родитель-потомок в Transform, где локальные трансформации потомка зависят от родителя.",
    "tags": [
      "GameObject",
      "Компоненты",
      "C#",
      "Transform"
    ],
    "difficulty": "easy"
  },
  {
    "question": "В чем разница между мировым (world) и локальным (local) пространством?",
    "answer": "World space считается от начала сцены, а local space — от Transform родителя.",
    "tags": [
      "GameObject",
      "Компоненты",
      "C#",
      "Transform"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Что такое Scene в Unity?",
    "answer": "Scene — это asset, содержащий часть игры: уровень, меню или окружение.",
    "tags": [
      "Сцены",
      "Assets",
      "Сборка"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Можно ли иметь несколько Scene в одном проекте?",
    "answer": "Да, в проекте Unity обычно используется много сцен, включая одновременную работу с несколькими сценами.",
    "tags": [
      "Сцены",
      "Assets",
      "Сборка"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое окно New Scene и что в нем можно делать?",
    "answer": "Окно New Scene позволяет создавать сцены из шаблонов, управлять шаблонами и работать в multi-scene сценариях.",
    "tags": [
      "Сцены",
      "Assets",
      "Сборка"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как управлять Scene в Build Settings?",
    "answer": "В Scenes In Build можно добавлять, удалять, включать, отключать и менять порядок сцен в сборке.",
    "tags": [
      "Сцены",
      "Assets",
      "Сборка"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Какие типы сборок создает Unity?",
    "answer": "Unity поддерживает release-сборки для релиза и development-сборки для отладки и профилирования.",
    "tags": [
      "Сцены",
      "Assets",
      "Сборка"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое инкрементальный пайплайн сборки?",
    "answer": "Инкрементальная сборка пересобирает только изменившиеся артефакты, ускоряя итерации.",
    "tags": [
      "Сцены",
      "Assets",
      "Сборка"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое AssetBundle?",
    "answer": "AssetBundle — платформозависимый архив ассетов, который можно подгружать динамически в рантайме.",
    "tags": [
      "Сцены",
      "Assets",
      "Сборка",
      "AssetBundle"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Зачем использовать AssetBundle?",
    "answer": "AssetBundle уменьшают начальный размер сборки и позволяют подгружать контент по требованию.",
    "tags": [
      "Сцены",
      "Assets",
      "Сборка",
      "AssetBundle"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Чем AssetBundle отличаются от папки Resources?",
    "answer": "Resources включаются в основной билд, а AssetBundle хранятся отдельно и загружаются по мере необходимости.",
    "tags": [
      "Сцены",
      "Assets",
      "Сборка",
      "AssetBundle"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как создавать сборки под конкретные платформы?",
    "answer": "В Build Settings выберите целевую платформу и переключитесь на нее, чтобы Unity переимпортировала нужные ассеты.",
    "tags": [
      "Сцены",
      "Assets",
      "Сборка",
      "Платформы"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Зачем сжимать AssetBundle?",
    "answer": "Сжатие уменьшает размер загрузки: LZ4 быстрее в использовании, LZMA дает более высокую степень сжатия.",
    "tags": [
      "Сцены",
      "Assets",
      "Сборка",
      "AssetBundle",
      "Платформы"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое Rigidbody и почему он необходим для физики?",
    "answer": "Rigidbody позволяет объекту участвовать в физике: реагировать на силы, гравитацию и столкновения.",
    "tags": [
      "Physics",
      "Rigidbody",
      "Математика"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Как Unity симулирует физику для Rigidbody?",
    "answer": "Физический движок обновляет скорость и столкновения на основе параметров Rigidbody и приложенных сил.",
    "tags": [
      "Physics",
      "Rigidbody",
      "Математика"
    ],
    "difficulty": "easy"
  },
  {
    "question": "В чем разница между кинематическими и некинематическими Rigidbody?",
    "answer": "Динамические Rigidbody управляются физикой, а кинематические двигаются скриптом и игнорируют силы.",
    "tags": [
      "Physics",
      "Rigidbody",
      "Математика"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Когда использовать FixedUpdate для расчетов физики?",
    "answer": "Применяйте силы и физическую логику в FixedUpdate для стабильной симуляции с фиксированным шагом.",
    "tags": [
      "Physics",
      "Rigidbody",
      "Математика"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Чем отличаются коллайдеры и триггеры?",
    "answer": "Обычные коллайдеры физически блокируют, а триггеры только отслеживают пересечения без блокировки.",
    "tags": [
      "Physics",
      "Rigidbody",
      "Математика",
      "Коллайдеры"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Как отслеживать события столкновений в скрипте?",
    "answer": "Реализуйте OnCollisionEnter(Collision c); нужен как минимум один некинематический Rigidbody у участвующих объектов.",
    "tags": [
      "Physics",
      "Rigidbody",
      "Математика",
      "Коллайдеры"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Как применять силу к Rigidbody?",
    "answer": "Используйте AddForce или AddTorque, обычно в FixedUpdate, с подходящим ForceMode.",
    "tags": [
      "Physics",
      "Rigidbody",
      "Математика"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Почему следует избегать масштабирования Rigidbody во время выполнения?",
    "answer": "Масштабирование в рантайме может искажать коллайдеры и вызывать нестабильные или непредсказуемые столкновения.",
    "tags": [
      "Physics",
      "Rigidbody",
      "Математика"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Как создать триггерную зону, которая не мешает физике?",
    "answer": "Добавьте коллайдер и установите isTrigger=true — он будет вызывать события триггера без физической блокировки.",
    "tags": [
      "Physics",
      "Rigidbody",
      "Математика",
      "Коллайдеры"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Как работает Input.GetAxis?",
    "answer": "Input.GetAxis возвращает сглаженное значение оси в диапазоне от -1 до 1 и не зависит от FPS.",
    "tags": [
      "Input",
      "Time",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Почему Input.GetAxis нужно умножать на Time.deltaTime?",
    "answer": "deltaTime переводит ввод из «за кадр» в «за секунду», сохраняя одинаковую скорость движения при разном FPS.",
    "tags": [
      "Input",
      "Time",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Какие две системы ввода есть в Unity?",
    "answer": "Unity поддерживает старую систему Input Manager и новую систему Input System Package.",
    "tags": [
      "Input",
      "Time",
      "C#",
      "Системы ввода"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Как UI Toolkit обрабатывает ввод?",
    "answer": "UI Toolkit использует event system для маршрутизации событий ввода в активные UI-панели в Play Mode.",
    "tags": [
      "Input",
      "Time",
      "C#",
      "Системы ввода"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Как выбрать активную систему ввода?",
    "answer": "Активная система ввода задается в Player Settings через Active Input Handling: Input Manager, Input System или Both.",
    "tags": [
      "Input",
      "Time",
      "C#",
      "Системы ввода"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Для чего нужен компонент EventSystem в Unity UI?",
    "answer": "EventSystem обрабатывает ввод с мыши, клавиатуры и геймпада и отправляет события UI-элементам.",
    "tags": [
      "Input",
      "Time",
      "C#",
      "Системы ввода"
    ],
    "difficulty": "easy"
  },
  {
    "question": "В чем разница между Input.GetAxis и Input.GetAxisRaw?",
    "answer": "GetAxis дает сглаженное значение, а GetAxisRaw возвращает мгновенное несглаженное цифровое значение.",
    "tags": [
      "Input",
      "Time",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Как обрабатывать ввод для нескольких игроков?",
    "answer": "Используйте PlayerInput с отдельными схемами управления и устройствами для каждого игрока.",
    "tags": [
      "Input",
      "Time",
      "C#",
      "Системы ввода"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Что такое Time.deltaTime и почему он важен при обработке ввода?",
    "answer": "Time.deltaTime — время с прошлого кадра; оно используется для нормализации скорости движения между разными FPS.",
    "tags": [
      "Input",
      "Time",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Что такое Canvas в Unity UI?",
    "answer": "Canvas — корневой контейнер, в котором должны находиться все элементы uGUI для корректной отрисовки.",
    "tags": [
      "UI",
      "Rendering"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Что произойдет, если создать UI-элемент без Canvas?",
    "answer": "Unity автоматически создаст Canvas и поместит новый UI-элемент внутрь него.",
    "tags": [
      "UI",
      "Rendering"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Какие есть режимы рендеринга Canvas?",
    "answer": "Режимы Canvas: Screen Space - Overlay, Screen Space - Camera и World Space.",
    "tags": [
      "UI",
      "Rendering",
      "Layout"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как определяется порядок отрисовки UI-элементов?",
    "answer": "Порядок отрисовки UI определяется порядком объектов в иерархии внутри Canvas.",
    "tags": [
      "UI",
      "Rendering",
      "Layout"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Почему UI-элементы используют RectTransform вместо Transform?",
    "answer": "RectTransform добавляет якоря, pivot и размеры, что нужно для адаптивной 2D-верстки интерфейса.",
    "tags": [
      "UI",
      "Rendering",
      "Layout"
    ],
    "difficulty": "medium"
  },
  {
    "question": "В чем разница между UI Toolkit и Unity UI (uGUI)?",
    "answer": "UI Toolkit — более современный стиль-ориентированный подход (UXML/USS), uGUI — компонентный подход на GameObject/Canvas.",
    "tags": [
      "UI",
      "Rendering",
      "UI Toolkit"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как сделать UI-элемент адаптивным под разные разрешения?",
    "answer": "Используйте anchors, pivots и layout-компоненты для адаптации размеров и позиций под разные экраны.",
    "tags": [
      "UI",
      "Rendering",
      "Layout"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое Raycast Target и почему это важно?",
    "answer": "Raycast Target определяет, принимает ли UI-графика события указателя и блокирует ли их прохождение дальше.",
    "tags": [
      "UI",
      "Rendering"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Как обрабатывать события ввода на UI-элементах?",
    "answer": "В uGUI используйте event-интерфейсы и callbacks компонентов, в UI Toolkit — зарегистрированные callbacks элементов.",
    "tags": [
      "UI",
      "Rendering",
      "UI Toolkit"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое ScriptableObject?",
    "answer": "ScriptableObject — это контейнер данных в виде asset-файла, независимый от объектов сцены.",
    "tags": [
      "ScriptableObject",
      "Данные",
      "Архитектура",
      "C#"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Когда стоит использовать ScriptableObject вместо MonoBehaviour?",
    "answer": "Используйте ScriptableObject для общих настроек и данных, которые должны жить отдельно от экземпляров в сцене.",
    "tags": [
      "ScriptableObject",
      "Данные",
      "Архитектура",
      "C#"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Как создать asset ScriptableObject?",
    "answer": "Наследуйтесь от ScriptableObject, при необходимости добавьте CreateAssetMenu, затем создайте и сохраните экземпляр asset.",
    "tags": [
      "ScriptableObject",
      "Данные",
      "Архитектура",
      "C#"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Как ScriptableObject улучшают использование памяти по сравнению с MonoBehaviour?",
    "answer": "ScriptableObject централизует данные в одном asset вместо дублирования во множестве объектов сцены.",
    "tags": [
      "ScriptableObject",
      "Данные",
      "Архитектура",
      "C#"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Могут ли ScriptableObject содержать поведение?",
    "answer": "Методы в ScriptableObject возможны, но покадровую логику обычно оставляют в MonoBehaviour.",
    "tags": [
      "ScriptableObject",
      "Данные",
      "Архитектура",
      "C#"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Как редактировать данные ScriptableObject в Inspector?",
    "answer": "Создайте или выберите asset ScriptableObject и редактируйте сериализуемые поля в Inspector.",
    "tags": [
      "ScriptableObject",
      "Данные",
      "Архитектура",
      "C#"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Как запустить корутину?",
    "answer": "Запускайте корутину вызовом StartCoroutine(SomeIEnumerator()) из MonoBehaviour.",
    "tags": [
      "Корутины",
      "C#",
      "Performance"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как остановить выполняющуюся корутину?",
    "answer": "Для одной корутины используйте StopCoroutine(reference), для всех на компоненте — StopAllCoroutines().",
    "tags": [
      "Корутины",
      "C#",
      "Performance"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Почему следует избегать долгих блокирующих задач в корутинах?",
    "answer": "Корутины работают на главном потоке, поэтому тяжелые операции в них все равно блокируют игру и рендер.",
    "tags": [
      "Корутины",
      "C#",
      "Performance",
      "Память"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что делает yield return null в корутине?",
    "answer": "yield return null приостанавливает корутину до следующего кадра.",
    "tags": [
      "Корутины",
      "C#",
      "Performance"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как выполнять код на каждом фиксированном тике внутри корутины?",
    "answer": "Используйте yield return new WaitForFixedUpdate(), чтобы синхронизироваться с физическими тиками.",
    "tags": [
      "Корутины",
      "C#",
      "Performance"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Почему стоит кэшировать экземпляры WaitForSeconds?",
    "answer": "Переиспользование WaitForSeconds уменьшает количество аллокаций и снижает пики сборщика мусора.",
    "tags": [
      "Корутины",
      "C#",
      "Performance",
      "Память"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое NavMesh?",
    "answer": "NavMesh — это запеченная проходимая геометрия для поиска пути агентами вокруг препятствий.",
    "tags": [
      "NavMesh",
      "AI",
      "Математика"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как сгенерировать NavMesh в Unity?",
    "answer": "Пометьте геометрию для навигации и выполните bake NavMesh в настройках навигации.",
    "tags": [
      "NavMesh",
      "AI",
      "Математика"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как агенты используют NavMesh для поиска пути?",
    "answer": "NavMeshAgent вычисляет и проходит маршрут после установки точки назначения.",
    "tags": [
      "NavMesh",
      "AI",
      "Математика"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое слои NavMesh и off-mesh links?",
    "answer": "Слои NavMesh фильтруют доступные зоны, а off-mesh links соединяют области для прыжков, дверей и разрывов.",
    "tags": [
      "NavMesh",
      "AI",
      "Математика"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как обрабатывать движущиеся препятствия с NavMesh?",
    "answer": "Для движущихся препятствий используйте NavMeshObstacle с carving или динамические обновления/локальное избегание.",
    "tags": [
      "NavMesh",
      "AI",
      "Математика"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое Animation State Machine?",
    "answer": "Animation State Machine — это граф состояний и переходов, который задает логику проигрывания анимаций.",
    "tags": [
      "Animation",
      "Animator",
      "Rendering"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое Animator Controller?",
    "answer": "Animator Controller хранит состояния, переходы, слои и blend trees для управления анимациями.",
    "tags": [
      "Animation",
      "Animator",
      "Rendering"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое параметры анимации в Animator?",
    "answer": "Параметры Animator (float/int/bool/trigger) управляют переходами и смешиванием анимаций.",
    "tags": [
      "Animation",
      "Animator",
      "Rendering"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое переходы анимации?",
    "answer": "Переходы определяют, когда и как Animator переключается между состояниями.",
    "tags": [
      "Animation",
      "Animator",
      "Rendering"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое blend tree анимации?",
    "answer": "Blend tree плавно смешивает несколько клипов по управляющему параметру, например скорости.",
    "tags": [
      "Animation",
      "Animator",
      "Rendering"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое слой анимации?",
    "answer": "Слои анимации позволяют отдельным state machine управлять разными частями тела с переопределениями.",
    "tags": [
      "Animation",
      "Animator",
      "Rendering"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Почему сравнение Unity-объектов через == null отличается от ReferenceEquals?",
    "answer": "Unity переопределяет сравнение для UnityEngine.Object, поэтому == null может отличаться от реальной CLR-проверки null.",
    "tags": [
      "Performance",
      "C#",
      "Память",
      "Unity API"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Почему в Unity стоит избегать финализаторов C#?",
    "answer": "Финализаторы недетерминированы, выполняются в другом потоке и могут конфликтовать с API Unity главного потока.",
    "tags": [
      "Performance",
      "C#",
      "Память"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Какие риски для производительности связаны с частыми выделениями памяти в Unity?",
    "answer": "Частые аллокации увеличивают нагрузку на GC и вызывают фризы/скачки времени кадра.",
    "tags": [
      "Performance",
      "C#",
      "Память"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Почему стоит кэшировать компоненты, например результаты GetComponent?",
    "answer": "Повторные вызовы GetComponent дороги; лучше кэшировать ссылки в Awake/Start.",
    "tags": [
      "Performance",
      "C#",
      "Память"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Когда использовать Destroy, а когда DestroyImmediate?",
    "answer": "В геймплее используйте Destroy, а DestroyImmediate предназначен в основном для editor-сценариев.",
    "tags": [
      "Performance",
      "C#",
      "Память",
      "Unity API"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Почему в производительно-критичном коде стоит избегать LINQ?",
    "answer": "LINQ может создавать лишние аллокации и работать медленнее на горячих участках, например в Update.",
    "tags": [
      "Performance",
      "C#",
      "Память"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как плавно перемещать Rigidbody без Transform.Translate?",
    "answer": "Используйте Rigidbody.MovePosition или силы, чтобы движение оставалось корректным для физики.",
    "tags": [
      "Physics",
      "Rigidbody",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "В чем разница между Awake и OnEnable?",
    "answer": "Awake вызывается один раз при загрузке, а OnEnable — каждый раз при включении объекта/компонента.",
    "tags": [
      "MonoBehaviour",
      "Lifecycle",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Какое преимущество Addressables по сравнению с ручным управлением AssetBundle?",
    "answer": "Addressables дают более высокий уровень управления загрузкой и зависимостями по сравнению с низкоуровневым AssetBundle API.",
    "tags": [
      "Addressables",
      "AssetBundle",
      "Архитектура"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Какие преимущества дает development build при тестировании?",
    "answer": "Development build содержит символы отладки и профилировщик для диагностики и анализа производительности.",
    "tags": [
      "Сборка",
      "Отладка",
      "Performance"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как уменьшить нагрузку на сборщик мусора, связанную с корутинами?",
    "answer": "Кэшируйте и переиспользуйте yield-инструкции вроде WaitForSeconds вместо постоянного создания новых.",
    "tags": [
      "Корутины",
      "Performance",
      "Память"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как централизовать конфигурационные данные, доступные между Scene?",
    "answer": "Храните общие настройки в ScriptableObject asset и ссылайтесь на него из объектов сцен.",
    "tags": [
      "ScriptableObject",
      "Архитектура",
      "Данные"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Как Time.timeScale влияет на ожидание корутин, например WaitForSeconds?",
    "answer": "WaitForSeconds работает в масштабируемом времени: уменьшение timeScale замедляет ожидание, timeScale=0 ставит его на паузу.",
    "tags": [
      "Time",
      "Корутины",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Что такое Time.deltaTime и почему его используют с Input.GetAxis?",
    "answer": "deltaTime переводит ввод осей в скорость в секунду, делая управление независимым от частоты кадров.",
    "tags": [
      "Input",
      "Time",
      "C#"
    ],
    "difficulty": "easy"
  },
  {
    "question": "Почему следует избегать дорогих операций в Update?",
    "answer": "Update вызывается каждый кадр, поэтому тяжелые операции в нем быстро ухудшают производительность.",
    "tags": [
      "Performance",
      "C#"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Для чего нужно слоение UI внутри Canvas?",
    "answer": "Слоение в иерархии управляет порядком отрисовки и позволяет держать оверлеи поверх основного контента.",
    "tags": [
      "UI",
      "Rendering",
      "Layout"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как реализовать динамическую загрузку Scene или ассетов во время выполнения?",
    "answer": "Используйте AssetBundle или Addressables для загрузки контента по требованию и контроля памяти.",
    "tags": [
      "Addressables",
      "AssetBundle",
      "Сцены"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое разделение данных и MV-паттерны в Unity?",
    "answer": "Это разделение Model (данные), View (MonoBehaviour/UI) и логики (Presenter/ViewModel). Цель — убрать бизнес-логику из MonoBehaviour, повысить тестируемость и снизить связанность.",
    "sources": [],
    "tags": [
      "Architecture",
      "UI"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Разница между MVP и MVC?",
    "answer": "MVC: View может напрямую читать Model, Controller управляет процессом. MVP: View полностью пассивна и работает через Presenter по интерфейсу. В Unity чаще MVP из-за природы MonoBehaviour.",
    "sources": [],
    "tags": [
      "Architecture",
      "UI"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Разница между MVP и MVVM?",
    "answer": "MVVM использует биндинг и реактивность (UniRx/R3). View подписывается на ViewModel. MVP более прямолинейный и проще в дебаге.",
    "sources": [],
    "tags": [
      "Architecture",
      "UI"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что такое Core архитектура новой игры?",
    "answer": "Разделение на Core (чистая логика), Infrastructure (Unity адаптеры), Gameplay, UI, Composition Root. Используется DI, StateMachine, события. Бизнес-логика не зависит от Unity API.",
    "sources": [],
    "tags": [
      "Architecture"
    ],
    "difficulty": "hard"
  },
  {
    "question": "DI, Singleton, Service Locator — различия?",
    "answer": "DI — явная передача зависимостей, лучше тестируется, соответствует SOLID. Singleton — глобальная точка доступа, высокая связанность. Service Locator — реестр сервисов, но зависимости скрыты.",
    "sources": [],
    "tags": [
      "Architecture"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Связь DI с принципом D из SOLID?",
    "answer": "Dependency Inversion Principle: модули зависят от абстракций. DI реализует этот принцип через инъекцию интерфейсов вместо конкретных классов.",
    "sources": [],
    "tags": [
      "Architecture"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что такое UniRx / R3?",
    "answer": "Реактивные библиотеки для работы с потоками событий. Позволяют строить подписки вместо Update, управлять потоками и временем. Требуют аккуратного Dispose.",
    "sources": [],
    "tags": [
      "Reactive"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Виды ECS?",
    "answer": "Object-oriented ECS, Sparse-set ECS (EnTT, Flecs), Archetype ECS (DOTS). Отличаются способом хранения компонентов и группировки сущностей.",
    "sources": [],
    "tags": [
      "ECS"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что такое Sparse-set ECS?",
    "answer": "Использует dense и sparse массивы для двойной индексации. Позволяет O(1) добавление/удаление и плотное хранение данных.",
    "sources": [],
    "tags": [
      "ECS"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что такое архетипный ECS?",
    "answer": "Сущности группируются по набору компонентов (архетипу). Компоненты хранятся плотными массивами. Высокая cache-friendly производительность.",
    "sources": [],
    "tags": [
      "ECS"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Почему не LeoEcs?",
    "answer": "Меньше tooling и контроля над памятью, слабее масштабируется по сравнению с DOTS. Подходит для небольших проектов.",
    "sources": [],
    "tags": [
      "ECS"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Как очищаются сущности в ECS?",
    "answer": "Обычно помечаются на удаление и очищаются в конце фрейма. Компоненты удаляются из плотных массивов или возвращаются в пул.",
    "sources": [],
    "tags": [
      "ECS"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что такое мультимиры в ECS?",
    "answer": "Несколько миров (Gameplay, UI, StateMachine). Позволяют разделять ответственность и изолировать логику.",
    "sources": [],
    "tags": [
      "ECS"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что оставить в ООП, а что в ECS?",
    "answer": "В ECS — данные и массовые вычисления. В ООП — сервисы, инфраструктура, UI, интеграции.",
    "sources": [],
    "tags": [
      "ECS",
      "Architecture"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Как устроен List<T>?",
    "answer": "Динамический массив. При превышении capacity создаётся новый массив большего размера и элементы копируются.",
    "sources": [],
    "tags": [
      "Collections"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как работает Remove в List и как оптимизировать?",
    "answer": "Remove сдвигает элементы — O(n). Если порядок не важен, можно заменить удаляемый элемент последним и уменьшить Count — O(1).",
    "sources": [],
    "tags": [
      "Collections"
    ],
    "difficulty": "medium"
  },
  {
    "question": "List vs Array со структурами?",
    "answer": "Array фиксированного размера, без аллокаций на resize. List добавляет overhead при расширении. Для struct массив более предсказуем по памяти.",
    "sources": [],
    "tags": [
      "Memory",
      "Collections"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Как работает Dictionary?",
    "answer": "Хеширование ключа → bucket → обработка коллизий. Resize при превышении load factor. Средняя сложность O(1).",
    "sources": [],
    "tags": [
      "Collections"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как передать ValueType по ссылке?",
    "answer": "Через ref, in, out. Можно использовать unsafe pointer. Это избегает копирования структуры.",
    "sources": [],
    "tags": [
      "C# Memory"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Как избежать боксинга?",
    "answer": "Не приводить struct к object или интерфейсу. Использовать generics с where T : struct.",
    "sources": [],
    "tags": [
      "C# Memory"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Как хранить миллиард точек?",
    "answer": "Использовать struct + массив или NativeArray. Нужно оценить доступную память, необходимость изменения размера и стратегию итерации.",
    "sources": [],
    "tags": [
      "Memory",
      "Performance"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Как работает GC в .NET?",
    "answer": "3 поколения (0,1,2), компактизация памяти, Large Object Heap. Молодые объекты очищаются чаще.",
    "sources": [],
    "tags": [
      "GC"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Как работает GC в Unity?",
    "answer": "Однопоколенный GC, без полноценной компактизации. Есть incremental режим. Возможны фризы при полной сборке.",
    "sources": [],
    "tags": [
      "GC",
      "Unity"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что такое асинхронность?",
    "answer": "Неблокирующее выполнение задач. Не равна многопоточности. Может работать в одном потоке через state machine.",
    "sources": [],
    "tags": [
      "Async"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Асинхронность vs многопоточность?",
    "answer": "Асинхронность — неблокирующая модель. Многопоточность — параллельное выполнение на нескольких потоках.",
    "sources": [],
    "tags": [
      "Async"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Может ли быть несколько потоков на одном ядре?",
    "answer": "Да, через планировщик ОС. Потоки получают квант времени и переключаются.",
    "sources": [],
    "tags": [
      "Threads"
    ],
    "difficulty": "hard"
  },
  {
    "question": "UniTask vs Task?",
    "answer": "UniTask оптимизирован под Unity, избегает аллокаций. Task использует стандартный .NET механизм.",
    "sources": [],
    "tags": [
      "Async",
      "Unity"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что такое ValueTask?",
    "answer": "Оптимизированная версия Task для уменьшения аллокаций, может завершаться синхронно.",
    "sources": [],
    "tags": [
      "Async"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Почему нельзя запускать корутину из внешнего потока?",
    "answer": "Unity API не потокобезопасен. Корутины работают в главном потоке.",
    "sources": [],
    "tags": [
      "Unity",
      "Threads"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Обязательно ли Task.Run создаёт новый поток?",
    "answer": "Нет, он использует ThreadPool. Поток может быть переиспользован.",
    "sources": [],
    "tags": [
      "Threads"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что такое ThreadPool?",
    "answer": "Пул рабочих потоков, управляемый CLR. Используется для фоновых задач.",
    "sources": [],
    "tags": [
      "Threads"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что делает ConfigureAwait(false)?",
    "answer": "Не возвращает выполнение в исходный SynchronizationContext.",
    "sources": [],
    "tags": [
      "Async"
    ],
    "difficulty": "hard"
  },
  {
    "question": "async void vs async Task?",
    "answer": "async void не позволяет обработать исключения и await. Используется только для event handler.",
    "sources": [],
    "tags": [
      "Async"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что такое SynchronizationContext?",
    "answer": "Механизм возврата выполнения в определённый поток (например, Unity main thread).",
    "sources": [],
    "tags": [
      "Async"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Task.WhenAll vs WhenAny?",
    "answer": "WhenAll ждёт завершения всех задач. WhenAny возвращает первую завершившуюся, но остальные продолжают работать.",
    "sources": [],
    "tags": [
      "Async"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что такое атомарные операции?",
    "answer": "Операции, выполняющиеся неделимо. Например Interlocked.Increment.",
    "sources": [],
    "tags": [
      "Concurrency"
    ],
    "difficulty": "hard"
  },
  {
    "question": "volatile и Interlocked — разница?",
    "answer": "volatile запрещает оптимизации кэша, но не гарантирует атомарность. Interlocked гарантирует атомарную операцию.",
    "sources": [],
    "tags": [
      "Concurrency"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Почему List не потокобезопасен?",
    "answer": "Нет синхронизации при изменении массива. Для потокобезопасности использовать ConcurrentCollection или lock.",
    "sources": [],
    "tags": [
      "Concurrency"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Как работает потокобезопасная очередь?",
    "answer": "Использует блокировки или lock-free алгоритмы с атомарными операциями.",
    "sources": [],
    "tags": [
      "Concurrency"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что такое SpinLock / SpinWait?",
    "answer": "Активное ожидание без перехода в состояние сна. Эффективно при коротких блокировках.",
    "sources": [],
    "tags": [
      "Concurrency"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Как решать гонку потоков?",
    "answer": "Использовать lock, атомарные операции, immutable данные или разделение ответственности.",
    "sources": [],
    "tags": [
      "Concurrency"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Как параллельно загружать N файлов и считать прогресс?",
    "answer": "Запустить задачи через Task.WhenAll, использовать потокобезопасный счётчик (Interlocked), прогресс отправлять в главный поток.",
    "sources": [],
    "tags": [
      "Async",
      "Threads"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что такое Addressables?",
    "answer": "Система управления ресурсами поверх AssetBundle. Управляет зависимостями, загрузкой и выгрузкой.",
    "sources": [],
    "tags": [
      "Unity",
      "Assets"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Как резолвятся зависимости в AssetBundle?",
    "answer": "Если бандл зависит от другого, Unity автоматически загрузит зависимый бандл при обращении к ресурсу.",
    "sources": [],
    "tags": [
      "Unity",
      "Assets"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Если модель в одном бандле, текстура в другом — что будет?",
    "answer": "При загрузке модели автоматически подгрузится бандл с текстурой, если зависимость указана.",
    "sources": [],
    "tags": [
      "Unity",
      "Assets"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Destroy vs Release?",
    "answer": "Destroy удаляет объект сцены. Release уменьшает reference count Addressables. Ресурс выгружается при нуле ссылок.",
    "sources": [],
    "tags": [
      "Unity",
      "Assets"
    ],
    "difficulty": "medium"
  },
  {
    "question": "Что такое сетевой транспорт?",
    "answer": "Низкоуровневый слой передачи данных (UDP, TCP, WebSocket). Поверх него строятся сетевые фреймворки.",
    "sources": [],
    "tags": [
      "Networking"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Что такое конкурентность?",
    "answer": "Ситуация, когда несколько потоков обращаются к общему ресурсу.",
    "sources": [],
    "tags": [
      "Concurrency"
    ],
    "difficulty": "hard"
  },
  {
    "question": "Pinned объекты в GC?",
    "answer": "Объекты, которые нельзя перемещать. Могут вызывать фрагментацию памяти.",
    "sources": [],
    "tags": [
      "GC"
    ],
    "difficulty": "hard"
  }
]
